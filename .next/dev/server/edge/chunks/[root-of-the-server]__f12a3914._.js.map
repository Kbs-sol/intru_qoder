{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/logger.ts"],"sourcesContent":["import { nanoid } from \"nanoid\";\r\n\r\nexport type LogLevel = \"info\" | \"warning\" | \"error\";\r\n\r\nexport interface LogEntry {\r\n    user_id?: string;\r\n    action: string;\r\n    entity_type?: string;\r\n    entity_id?: string;\r\n    metadata?: Record<string, any>;\r\n    level?: LogLevel;\r\n}\r\n\r\n/**\r\n * Centralized logging service\r\n * Logs to console in development and (eventually) to D1 database in production\r\n */\r\nexport async function logActivity({\r\n    user_id,\r\n    action,\r\n    entity_type,\r\n    entity_id,\r\n    metadata,\r\n    level = \"info\",\r\n}: LogEntry) {\r\n    const timestamp = new Date().toISOString();\r\n\r\n    // In a real edge environment, we would access D1 via bindings context or an API route\r\n    // For now, in App Router server components/actions, we log to stdout which is captured by deployment logs\r\n\r\n    const logData = {\r\n        id: nanoid(),\r\n        timestamp,\r\n        level,\r\n        user_id,\r\n        action,\r\n        entity_type,\r\n        entity_id,\r\n        metadata,\r\n    };\r\n\r\n    // Structured logging for better parsing\r\n    console.log(JSON.stringify(logData));\r\n\r\n    // TODO: Insert into D1 'activity_logs' table\r\n    // This requires setting up the D1 client connection which depends on the specific runtime context (edge vs node)\r\n    // For Cloudflare Pages + Next.js, it's best to use a separate API route or server action that has the binding\r\n}\r\n\r\nexport async function logError(error: Error | string, context?: Record<string, any>) {\r\n    console.error(JSON.stringify({\r\n        timestamp: new Date().toISOString(),\r\n        level: \"error\",\r\n        message: error instanceof Error ? error.message : error,\r\n        stack: error instanceof Error ? error.stack : undefined,\r\n        context,\r\n    }));\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAiBO,eAAe,YAAY,EAC9B,OAAO,EACP,MAAM,EACN,WAAW,EACX,SAAS,EACT,QAAQ,EACR,QAAQ,MAAM,EACP;IACP,MAAM,YAAY,IAAI,OAAO,WAAW;IAExC,sFAAsF;IACtF,0GAA0G;IAE1G,MAAM,UAAU;QACZ,IAAI,IAAA,4KAAM;QACV;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;IAEA,wCAAwC;IACxC,QAAQ,GAAG,CAAC,KAAK,SAAS,CAAC;AAE3B,6CAA6C;AAC7C,iHAAiH;AACjH,8GAA8G;AAClH;AAEO,eAAe,SAAS,KAAqB,EAAE,OAA6B;IAC/E,QAAQ,KAAK,CAAC,KAAK,SAAS,CAAC;QACzB,WAAW,IAAI,OAAO,WAAW;QACjC,OAAO;QACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD,OAAO,iBAAiB,QAAQ,MAAM,KAAK,GAAG;QAC9C;IACJ;AACJ"}},
    {"offset": {"line": 57, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/security.ts"],"sourcesContent":["import { logActivity } from \"./logger\";\r\n\r\nexport interface SecurityEvent {\r\n    event_type: \"LOGIN_FAILED\" | \"SUSPICIOUS_ACTIVITY\" | \"BLOCKED_IP\" | \"PASSWORD_RESET\" | \"ADMIN_ACCESS\";\r\n    user_id?: string;\r\n    ip_address?: string;\r\n    severity: \"low\" | \"medium\" | \"high\" | \"critical\";\r\n    details?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Log security related events\r\n */\r\nexport async function logSecurityEvent({\r\n    event_type,\r\n    user_id,\r\n    ip_address,\r\n    severity,\r\n    details,\r\n}: SecurityEvent) {\r\n    await logActivity({\r\n        user_id,\r\n        action: `SECURITY_${event_type}`,\r\n        entity_type: \"security_event\",\r\n        metadata: {\r\n            ip_address, // In real implementation, this would be extracted from request headers safely\r\n            severity,\r\n            details,\r\n        },\r\n        level: severity === \"low\" ? \"info\" : \"error\",\r\n    });\r\n\r\n    // TODO: If severity is high/critical, trigger alerts (e.g., email to admin)\r\n    if (severity === \"critical\") {\r\n        console.error(`CRITICAL SECURITY EVENT: ${event_type} from IP ${ip_address}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Simple in-memory rate limiter for demo purposes\r\n * In production, use Cloudflare KV or Rate Limiting API\r\n */\r\nconst rateLimitMap = new Map<string, { count: number; timestamp: number }>();\r\n\r\nexport function checkRateLimit(ip: string, limit: number = 100, windowMs: number = 60000): boolean {\r\n    const now = Date.now();\r\n    const record = rateLimitMap.get(ip);\r\n\r\n    if (!record) {\r\n        rateLimitMap.set(ip, { count: 1, timestamp: now });\r\n        return true;\r\n    }\r\n\r\n    if (now - record.timestamp > windowMs) {\r\n        // Reset window\r\n        rateLimitMap.set(ip, { count: 1, timestamp: now });\r\n        return true;\r\n    }\r\n\r\n    if (record.count >= limit) {\r\n        return false; // Rate limit exceeded\r\n    }\r\n\r\n    record.count++;\r\n    return true;\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAaO,eAAe,iBAAiB,EACnC,UAAU,EACV,OAAO,EACP,UAAU,EACV,QAAQ,EACR,OAAO,EACK;IACZ,MAAM,IAAA,oIAAW,EAAC;QACd;QACA,QAAQ,CAAC,SAAS,EAAE,YAAY;QAChC,aAAa;QACb,UAAU;YACN;YACA;YACA;QACJ;QACA,OAAO,aAAa,QAAQ,SAAS;IACzC;IAEA,4EAA4E;IAC5E,IAAI,aAAa,YAAY;QACzB,QAAQ,KAAK,CAAC,CAAC,yBAAyB,EAAE,WAAW,SAAS,EAAE,YAAY;IAChF;AACJ;AAEA;;;CAGC,GACD,MAAM,eAAe,IAAI;AAElB,SAAS,eAAe,EAAU,EAAE,QAAgB,GAAG,EAAE,WAAmB,KAAK;IACpF,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,SAAS,aAAa,GAAG,CAAC;IAEhC,IAAI,CAAC,QAAQ;QACT,aAAa,GAAG,CAAC,IAAI;YAAE,OAAO;YAAG,WAAW;QAAI;QAChD,OAAO;IACX;IAEA,IAAI,MAAM,OAAO,SAAS,GAAG,UAAU;QACnC,eAAe;QACf,aAAa,GAAG,CAAC,IAAI;YAAE,OAAO;YAAG,WAAW;QAAI;QAChD,OAAO;IACX;IAEA,IAAI,OAAO,KAAK,IAAI,OAAO;QACvB,OAAO,OAAO,sBAAsB;IACxC;IAEA,OAAO,KAAK;IACZ,OAAO;AACX"}},
    {"offset": {"line": 114, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { getToken } from \"next-auth/jwt\";\r\nimport { checkRateLimit, logSecurityEvent } from \"@/lib/security\";\r\nimport type { NextRequest } from \"next/server\";\r\n\r\n// Removed: export { auth as middleware } from \"@/lib/auth\" \r\n// We are implementing a custom middleware function instead. \r\n// If we needed auth logic, we'd use `auth` wrapper, but here we do manual token check for admin.\r\n\r\n// Define paths that require authentication/admin privileges\r\nconst adminPaths = [\"/admin\"];\r\nconst protectedPaths = [\"/checkout\", \"/profile\"];\r\n\r\nexport async function middleware(request: NextRequest) {\r\n    const { pathname } = request.nextUrl;\r\n    // Fix: Access ip safely or providing fallback. NextRequest interface does extend Request which has no standard .ip, but Next.js adds it.\r\n    // Casting to any to avoid TS error if types are not up to date, or checking headers.\r\n    const ip = (request as any).ip || request.headers.get(\"x-forwarded-for\") || \"127.0.0.1\";\r\n\r\n    // 1. Security Headers\r\n    const response = NextResponse.next();\r\n    response.headers.set(\"X-Frame-Options\", \"DENY\");\r\n    response.headers.set(\"X-Content-Type-Options\", \"nosniff\");\r\n    response.headers.set(\"Referrer-Policy\", \"strict-origin-when-cross-origin\");\r\n    response.headers.set(\"Permissions-Policy\", \"camera=(), microphone=(), geolocation=()\");\r\n\r\n    // 2. Rate Limiting (Simple check)\r\n    if (!checkRateLimit(ip, 100, 60000)) { // 100 req/min\r\n        logSecurityEvent({\r\n            event_type: \"BLOCKED_IP\",\r\n            ip_address: ip,\r\n            severity: \"medium\",\r\n            details: { reason: \"rate_limit_exceeded\", path: pathname }\r\n        });\r\n        return new NextResponse(\"Too Many Requests\", { status: 429 });\r\n    }\r\n\r\n    // 3. Admin Route Protection\r\n    if (adminPaths.some(path => pathname.startsWith(path))) {\r\n        const token = await getToken({ req: request, secret: process.env.NEXTAUTH_SECRET });\r\n\r\n        if (!token) {\r\n            // Redirect to login if not authenticated\r\n            const url = new URL(\"/\", request.url);\r\n            url.searchParams.set(\"error\", \"unauthorized\");\r\n            return NextResponse.redirect(url);\r\n        }\r\n\r\n        if ((token as any).role !== \"admin\") {\r\n            // Log unauthorized admin access attempt\r\n            logSecurityEvent({\r\n                event_type: \"ADMIN_ACCESS\",\r\n                user_id: token.sub,\r\n                ip_address: ip,\r\n                severity: \"high\",\r\n                details: { status: \"unauthorized_role\", path: pathname }\r\n            });\r\n            return new NextResponse(\"Unauthorized\", { status: 403 });\r\n        }\r\n    }\r\n\r\n    return response;\r\n}\r\n\r\nexport const config = {\r\n    matcher: [\r\n        // Apply to all routes except static files\r\n        \"/((?!_next/static|_next/image|favicon.ico|images/).*)\",\r\n    ],\r\n};\r\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AAAA;AACA;;;;AAGA,4DAA4D;AAC5D,6DAA6D;AAC7D,iGAAiG;AAEjG,4DAA4D;AAC5D,MAAM,aAAa;IAAC;CAAS;AAC7B,MAAM,iBAAiB;IAAC;IAAa;CAAW;AAEzC,eAAe,WAAW,OAAoB;IACjD,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,OAAO;IACpC,yIAAyI;IACzI,qFAAqF;IACrF,MAAM,KAAK,AAAC,QAAgB,EAAE,IAAI,QAAQ,OAAO,CAAC,GAAG,CAAC,sBAAsB;IAE5E,sBAAsB;IACtB,MAAM,WAAW,gMAAY,CAAC,IAAI;IAClC,SAAS,OAAO,CAAC,GAAG,CAAC,mBAAmB;IACxC,SAAS,OAAO,CAAC,GAAG,CAAC,0BAA0B;IAC/C,SAAS,OAAO,CAAC,GAAG,CAAC,mBAAmB;IACxC,SAAS,OAAO,CAAC,GAAG,CAAC,sBAAsB;IAE3C,kCAAkC;IAClC,IAAI,CAAC,IAAA,yIAAc,EAAC,IAAI,KAAK,QAAQ;QACjC,IAAA,2IAAgB,EAAC;YACb,YAAY;YACZ,YAAY;YACZ,UAAU;YACV,SAAS;gBAAE,QAAQ;gBAAuB,MAAM;YAAS;QAC7D;QACA,OAAO,IAAI,gMAAY,CAAC,qBAAqB;YAAE,QAAQ;QAAI;IAC/D;IAEA,4BAA4B;IAC5B,IAAI,WAAW,IAAI,CAAC,CAAA,OAAQ,SAAS,UAAU,CAAC,QAAQ;QACpD,MAAM,QAAQ,MAAM,IAAA,yLAAQ,EAAC;YAAE,KAAK;YAAS,QAAQ,QAAQ,GAAG,CAAC,eAAe;QAAC;QAEjF,IAAI,CAAC,OAAO;YACR,yCAAyC;YACzC,MAAM,MAAM,IAAI,IAAI,KAAK,QAAQ,GAAG;YACpC,IAAI,YAAY,CAAC,GAAG,CAAC,SAAS;YAC9B,OAAO,gMAAY,CAAC,QAAQ,CAAC;QACjC;QAEA,IAAI,AAAC,MAAc,IAAI,KAAK,SAAS;YACjC,wCAAwC;YACxC,IAAA,2IAAgB,EAAC;gBACb,YAAY;gBACZ,SAAS,MAAM,GAAG;gBAClB,YAAY;gBACZ,UAAU;gBACV,SAAS;oBAAE,QAAQ;oBAAqB,MAAM;gBAAS;YAC3D;YACA,OAAO,IAAI,gMAAY,CAAC,gBAAgB;gBAAE,QAAQ;YAAI;QAC1D;IACJ;IAEA,OAAO;AACX;AAEO,MAAM,SAAS;IAClB,SAAS;QACL,0CAA0C;QAC1C;KACH;AACL"}}]
}